<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This macro is used to turn a regular struct into a self-referencing one. An example:"><meta name="keywords" content="rust, rustlang, rust-lang, self_referencing"><title>self_referencing in ouroboros - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../ouroboros/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../ouroboros/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In ouroboros</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="index.html">ouroboros</a>::<wbr><a class="attr" href="#">self_referencing</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/ouroboros_macro/lib.rs.html#114">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust"><code>#[self_referencing]</code></pre></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This macro is used to turn a regular struct into a self-referencing one. An example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ouroboros::self_referencing;

<span class="attr">#[self_referencing]
</span><span class="kw">struct </span>MyStruct {
    int_data: i32,
    float_data: f32,
    <span class="attr">#[borrows(int_data)]
    </span><span class="comment">// the &#39;this lifetime is created by the #[self_referencing] macro
    // and should be used on all references marked by the #[borrows] macro
    </span>int_reference: <span class="kw-2">&amp;</span><span class="lifetime">&#39;this </span>i32,
    <span class="attr">#[borrows(<span class="kw-2">mut </span>float_data)]
    </span>float_reference: <span class="kw-2">&amp;</span><span class="lifetime">&#39;this </span><span class="kw-2">mut </span>f32,
}

<span class="kw">fn </span>main() {
    <span class="comment">// The builder is created by the #[self_referencing] macro
    // and is used to create the struct
    </span><span class="kw">let </span><span class="kw-2">mut </span>my_value = MyStructBuilder {
        int_data: <span class="number">42</span>,
        float_data: <span class="number">3.14</span>,

        <span class="comment">// Note that the name of the field in the builder
        // is the name of the field in the struct + `_builder`
        // ie: {field_name}_builder
        // the closure that assigns the value for the field will be passed
        // a reference to the field(s) defined in the #[borrows] macro

        </span>int_reference_builder: |int_data: <span class="kw-2">&amp;</span>i32| int_data,
        float_reference_builder: |float_data: <span class="kw-2">&amp;mut </span>f32| float_data,
    }.build();

    <span class="comment">// The fields in the original struct can not be accesed directly
    // The builder creates accessor methods which are called borrow_{field_name}()

    // Prints 42
    </span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, my_value.borrow_int_data());
    <span class="comment">// Prints 3.14
    </span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, my_value.borrow_float_reference());
    <span class="comment">// Sets the value of float_data to 84.0
    </span>my_value.with_mut(|fields| {
        <span class="kw-2">**</span>fields.float_reference = (<span class="kw-2">**</span>fields.int_reference <span class="kw">as </span>f32) * <span class="number">2.0</span>;
    });

    <span class="comment">// We can hold on to this reference...
    </span><span class="kw">let </span>int_ref = <span class="kw-2">*</span>my_value.borrow_int_reference();
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">*</span>int_ref);
    <span class="comment">// As long as the struct is still alive.
    </span>drop(my_value);
    <span class="comment">// This will cause an error!
    // println!(&quot;{:?}&quot;, *int_ref);
</span>}</code></pre></div>
<p>To explain the features and limitations of this crate, some definitions are necessary:</p>
<h2 id="definitions"><a href="#definitions">Definitions</a></h2>
<ul>
<li><strong>immutably borrowed field</strong>: a field which is immutably borrowed by at least one other field.</li>
<li><strong>mutably borrowed field</strong>: a field which is mutably borrowed by exactly one other field.</li>
<li><strong>self-referencing field</strong>: a field which borrows at least one other field.</li>
<li><strong>head field</strong>: a field which does not borrow any other fields, I.E. not self-referencing.
This does not include fields with empty borrows annotations (<code>#[borrows()]</code>.)</li>
<li><strong>tail field</strong>: a field which is not borrowed by any other fields.</li>
</ul>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>To make a self-referencing struct, you must write a struct definition and place
<code>#[self_referencing]</code> on top. For every field that borrows other fields, you must place
<code>#[borrows()]</code> on top and place inside the parenthesis a list of fields that it borrows. Mut can
be prefixed to indicate that a mutable borrow is required. For example,
<code>#[borrows(a, b, mut c)]</code> indicates that the first two fields need to be borrowed immutably and
the third needs to be borrowed mutably. You can also use <code>#[borrows()]</code> without any arguments to
indicate a field that will eventually borrow from the struct, but does not borrow anything when
first created. For example, you could use this on a field like <code>error: Option&lt;&amp;'this str&gt;</code>.</p>
<h2 id="you-must-comply-with-these-limitations"><a href="#you-must-comply-with-these-limitations">You must comply with these limitations</a></h2>
<ul>
<li>Fields must be declared before the first time they are borrowed.</li>
<li>Normal borrowing rules apply, E.G. a field cannot be borrowed mutably twice.</li>
<li>Fields that use the <code>'this</code> lifetime must have a corresponding <code>#[borrows()]</code> annotation.
The error for this needs some work, currently you will get an error saying that <code>'this</code> is
undefined at the location it was illegally used in.</li>
</ul>
<p>Violating them will result in an error message directly pointing out the violated rule.</p>
<h2 id="flexibility-of-this-crate"><a href="#flexibility-of-this-crate">Flexibility of this crate</a></h2>
<p>The example above uses plain references as the self-referencing part of the struct, but you can
use anything that is dependent on lifetimes of objects inside the struct. For example, you could
do something like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ouroboros::self_referencing;

<span class="kw">pub struct </span>ComplexData&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; {
    aref: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>i32,
    bref: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span><span class="kw-2">mut </span>i32,
    number: i32,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; ComplexData&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; {
    <span class="kw">fn </span>new(aref: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>i32, bref: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span><span class="kw-2">mut </span>i32, number: i32) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ aref, bref, number }
    }

    <span class="doccomment">/// Copies the value aref points to into what bref points to.
    </span><span class="kw">fn </span>transfer(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="kw-2">*</span><span class="self">self</span>.bref = <span class="kw-2">*</span><span class="self">self</span>.aref;
    }

    <span class="doccomment">/// Prints the value bref points to.
    </span><span class="kw">fn </span>print_bref(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="self">self</span>.bref);
    }
}

<span class="kw">fn </span>main() {
    <span class="attr">#[self_referencing]
    </span><span class="kw">struct </span>DataStorage {
        immutable: i32,
        mutable: i32,
        <span class="attr">#[borrows(immutable, <span class="kw-2">mut </span>mutable)]
        #[covariant]
        </span>complex_data: ComplexData&lt;<span class="lifetime">&#39;this</span>, <span class="lifetime">&#39;this</span>&gt;,
    }

    <span class="kw">let </span><span class="kw-2">mut </span>data_storage = DataStorageBuilder {
        immutable: <span class="number">10</span>,
        mutable: <span class="number">20</span>,
        complex_data_builder: |i: <span class="kw-2">&amp;</span>i32, m: <span class="kw-2">&amp;mut </span>i32| ComplexData::new(i, m, <span class="number">12345</span>),
    }.build();
    data_storage.with_complex_data_mut(|data| {
        <span class="comment">// Copies the value in immutable into mutable.
        </span>data.transfer();
        <span class="comment">// Prints 10
        </span>data.print_bref();
    });
}</code></pre></div>
<h2 id="note-on-memory-leaks"><a href="#note-on-memory-leaks">Note on memory leaks</a></h2>
<p>Currently, if a builder panics when creating a field, all previous fields will be leaked. This
does not cause any undefined behavior. This behavior may be resolved in the future so that all
previous fields are dropped when a builder panics.</p>
<h2 id="covariance"><a href="#covariance">Covariance</a></h2>
<p>Many types in Rust have a property called “covariance”. In practical tearms, this means that a
covariant type like <code>Box&lt;&amp;'this i32&gt;</code> can be used as a <code>Box&lt;&amp;'a i32&gt;</code> as long as <code>'a</code> is
smaller than <code>'this</code>. Since the lifetime is smaller, it does not violate the lifetime specified
by the original type. Contrast this to <code>Fn(&amp;'this i32)</code>, which is not covariant. You cannot give
this function a reference with a lifetime shorter than <code>'this</code> as the function needs something
that lives at <em>least</em> as long as <code>'this</code>. Unfortunately, there is no easy way to determine
whether or not a type is covariant from inside the macro. As such, you may
receive a compiler error letting you know that the macro is uncertain if a particular field
uses a covariant type. Adding <code>#[covariant]</code> or <code>#[not_covariant]</code> will resolve this issue.</p>
<p>These annotations control whether or not a <code>borrow_*</code> method is generated for that field.
Incorrectly using one of these tags will result in a compilation error. It is impossible to
use them unsoundly.</p>
<h2 id="async-usage"><a href="#async-usage">Async usage</a></h2>
<p>All self-referencing structs can be initialized asynchronously by using either the
<code>MyStruct::new_async()</code> function or the <code>MyStructAsyncBuilder</code> builder. Due to limitations of
the rust compiler you closures must return a Future trait object wrapped in a <code>Pin&lt;Box&lt;_&gt;&gt;</code>.</p>
<p>Here is the same example as above in its async version:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ouroboros::self_referencing;

<span class="attr">#[self_referencing]
</span><span class="kw">struct </span>MyStruct {
    int_data: i32,
    float_data: f32,
    <span class="attr">#[borrows(int_data)]
    </span>int_reference: <span class="kw-2">&amp;</span><span class="lifetime">&#39;this </span>i32,
    <span class="attr">#[borrows(<span class="kw-2">mut </span>float_data)]
    </span>float_reference: <span class="kw-2">&amp;</span><span class="lifetime">&#39;this </span><span class="kw-2">mut </span>f32,
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>my_value = MyStructAsyncBuilder {
        int_data: <span class="number">42</span>,
        float_data: <span class="number">3.14</span>,
        int_reference_builder: |int_data: <span class="kw-2">&amp;</span>i32| Box::pin(<span class="kw">async move </span>{ int_data }),
        float_reference_builder: |float_data: <span class="kw-2">&amp;mut </span>f32| Box::pin(<span class="kw">async move </span>{ float_data }),
    }.build().<span class="kw">await</span>;

    <span class="comment">// Prints 42
    </span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, my_value.borrow_int_data());
    <span class="comment">// Prints 3.14
    </span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, my_value.borrow_float_reference());
    <span class="comment">// Sets the value of float_data to 84.0
    </span>my_value.with_mut(|fields| {
        <span class="kw-2">**</span>fields.float_reference = (<span class="kw-2">**</span>fields.int_reference <span class="kw">as </span>f32) * <span class="number">2.0</span>;
    });

    <span class="comment">// We can hold on to this reference...
    </span><span class="kw">let </span>int_ref = <span class="kw-2">*</span>my_value.borrow_int_reference();
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">*</span>int_ref);
    <span class="comment">// As long as the struct is still alive.
    </span>drop(my_value);
    <span class="comment">// This will cause an error!
    // println!(&quot;{:?}&quot;, *int_ref);
</span>}</code></pre></div>
<h2 id="async-send"><a href="#async-send">Async Send</a></h2>
<p>When Send trait is needed, the Send variant of async methods and builders is available.</p>
<p>Here is the same example as above in its async send version:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ouroboros::self_referencing;

<span class="attr">#[self_referencing]
</span><span class="kw">struct </span>MyStruct {
    int_data: i32,
    float_data: f32,
    <span class="attr">#[borrows(int_data)]
    </span>int_reference: <span class="kw-2">&amp;</span><span class="lifetime">&#39;this </span>i32,
    <span class="attr">#[borrows(<span class="kw-2">mut </span>float_data)]
    </span>float_reference: <span class="kw-2">&amp;</span><span class="lifetime">&#39;this </span><span class="kw-2">mut </span>f32,
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>my_value = MyStructAsyncSendBuilder {
        int_data: <span class="number">42</span>,
        float_data: <span class="number">3.14</span>,
        int_reference_builder: |int_data: <span class="kw-2">&amp;</span>i32| Box::pin(<span class="kw">async move </span>{ int_data }),
        float_reference_builder: |float_data: <span class="kw-2">&amp;mut </span>f32| Box::pin(<span class="kw">async move </span>{ float_data }),
    }.build().<span class="kw">await</span>;

    <span class="comment">// Prints 42
    </span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, my_value.borrow_int_data());
    <span class="comment">// Prints 3.14
    </span><span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, my_value.borrow_float_reference());
    <span class="comment">// Sets the value of float_data to 84.0
    </span>my_value.with_mut(|fields| {
        <span class="kw-2">**</span>fields.float_reference = (<span class="kw-2">**</span>fields.int_reference <span class="kw">as </span>f32) * <span class="number">2.0</span>;
    });

    <span class="comment">// We can hold on to this reference...
    </span><span class="kw">let </span>int_ref = <span class="kw-2">*</span>my_value.borrow_int_reference();
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">*</span>int_ref);
    <span class="comment">// As long as the struct is still alive.
    </span>drop(my_value);
    <span class="comment">// This will cause an error!
    // println!(&quot;{:?}&quot;, *int_ref);
</span>}</code></pre></div>
<h2 id="what-does-the-macro-generate"><a href="#what-does-the-macro-generate">What does the macro generate?</a></h2>
<p>The <code>#[self_referencing]</code> struct will replace your definition with an unsafe self-referencing
struct with a safe public interface. Many functions will be generated depending on your original
struct definition. Documentation is generated for all items, so building documentation for
your project allows accessing detailed information about available functions. Using
<code>#[self_referencing(no_doc)]</code> will hide the generated items from documentation if it is becoming
too cluttered.</p>
<h4 id="a-quick-note-on-visibility"><a href="#a-quick-note-on-visibility">A quick note on visibility</a></h4>
<p>The visibility of generated items is dependent on one of two things. If the
generated item is related to a specific field of the struct, it uses the visibility of the
original field. (The actual field in the struct will be made private since accessing it could cause
undefined behavior.) If the generated item is not related to any particular field, it will by
default only be visible to the module the struct is declared in. (This includes things like
<code>new()</code> and <code>with()</code>.) You can use <code>#[self_referencing(pub_extras)]</code> to make these items have the
same visibility as the struct itself.</p>
<h2 id="list-of-generated-items"><a href="#list-of-generated-items">List of generated items</a></h2><h4 id="mystructnewfields---mystruct"><a href="#mystructnewfields---mystruct"><code>MyStruct::new(fields...) -&gt; MyStruct</code></a></h4>
<p>A basic constructor. It accepts values for each field in the order you declared them in. For
<strong>head fields</strong>, you only need to pass in what value it should have and it will be moved in
to the output. For <strong>self-referencing fields</strong>, you must provide a function or closure which creates
the value based on the values it borrows. A field using the earlier example of
<code>#[borrow(a, b, mut c)]</code> would require a function typed as
<code>FnOnce(a: &amp;_, b: &amp;_, c: &amp;mut _) -&gt; _</code>. Fields which have an empty borrows annotation
(<code>#[borrows()]</code>) should have their value directly passed in. A field using the earlier example
of <code>Option&lt;&amp;'this str&gt;</code> would require an input of <code>None</code>. Do not pass a function. Do not collect
200 dollars.</p>
<h4 id="mystructnew_asyncfields---mystruct"><a href="#mystructnew_asyncfields---mystruct"><code>MyStruct::new_async(fields...) -&gt; MyStruct</code></a></h4>
<p>A basic async constructor. It works identically to the sync constructor differing only in the
type of closures it expects. Whenever a closure is required it is expected to return a Pinned
and Boxed Future that Outputs the same type as the synchronous version.</p>
<h4 id="mystructnew_async_sendfields---mystruct"><a href="#mystructnew_async_sendfields---mystruct"><code>MyStruct::new_async_send(fields...) -&gt; MyStruct</code></a></h4>
<p>An async send constructor. It works identically to the sync constructor differing only in the
Send trait being specified in the return type.</p>
<h4 id="mystructbuilder"><a href="#mystructbuilder"><code>MyStructBuilder</code></a></h4>
<p>This is the preferred way to create a new instance of your struct. It is similar to using the
<code>MyStruct { a, b, c, d }</code> syntax instead of <code>MyStruct::new(a, b, c, d)</code>. It contains one field
for every argument in the actual constructor. <strong>Head fields</strong> have the same name that you
originally defined them with. <strong>self-referencing fields</strong> are suffixed with <code>_builder</code> since you need
to provide a function instead of a value. Fields with an empty borrows annotation are not
initialized using builders. Calling <code>.build()</code> on an instance of <code>MyStructBuilder</code>
will convert it to an instance of <code>MyStruct</code> by calling all <code>_builder</code> functions in the order that
they were declared and storing their results.</p>
<h4 id="mystructasyncbuilder"><a href="#mystructasyncbuilder"><code>MyStructAsyncBuilder</code></a></h4>
<p>This is the preferred way to asynchronously create a new instance of your struct. It works
identically to the synchronous builder differing only in the type of closures it expects. In
particular, all builder functions are called serially in the order that they were declared.
Whenever a closure is required it is expected to return a Pinned and Boxed Future that Outputs
the same type as the synchronous version.</p>
<h4 id="mystructasyncsendbuilder"><a href="#mystructasyncsendbuilder"><code>MyStructAsyncSendBuilder</code></a></h4>
<p>Same as MyStructAsyncBuilder, but with Send trait specified in the return type.</p>
<h4 id="mystructtry_newefields---resultmystruct-e"><a href="#mystructtry_newefields---resultmystruct-e"><code>MyStruct::try_new&lt;E&gt;(fields...) -&gt; Result&lt;MyStruct, E&gt;</code></a></h4>
<p>Similar to the regular <code>new()</code> function, except the functions wich create values for all
<strong>self-referencing fields</strong> can return <code>Result&lt;&gt;</code>s. If any of those are <code>Err</code>s, that error will be
returned instead of an instance of <code>MyStruct</code>. The preferred way to use this function is through
<code>MyStructTryBuilder</code> and its <code>try_build()</code> function.</p>
<h4 id="mystructtry_new_asyncefields---resultmystruct-e"><a href="#mystructtry_new_asyncefields---resultmystruct-e"><code>MyStruct::try_new_async&lt;E&gt;(fields...) -&gt; Result&lt;MyStruct, E&gt;</code></a></h4>
<p>Similar to the regular <code>new_async()</code> function, except the functions wich create values for all
<strong>self-referencing fields</strong> can return <code>Result&lt;&gt;</code>s. If any of those are <code>Err</code>s, that error will be
returned instead of an instance of <code>MyStruct</code>. The preferred way to use this function is through
<code>MyStructAsyncTryBuilder</code> and its <code>try_build()</code> function.</p>
<h4 id="mystructtry_new_async_sendefields---resultmystruct-e"><a href="#mystructtry_new_async_sendefields---resultmystruct-e"><code>MyStruct::try_new_async_send&lt;E&gt;(fields...) -&gt; Result&lt;MyStruct, E&gt;</code></a></h4>
<p>Same as <code>new_async()</code> function, but with Send trait specified in the return type.</p>
<h4 id="mystructtry_new_or_recover_asyncefields---resultmystruct-e-heads"><a href="#mystructtry_new_or_recover_asyncefields---resultmystruct-e-heads"><code>MyStruct::try_new_or_recover_async&lt;E&gt;(fields...) -&gt; Result&lt;MyStruct, (E, Heads)&gt;</code></a></h4>
<p>Similar to the <code>try_new_async()</code> function, except that all the <strong>head fields</strong> are returned along side
the original error in case of an error. The preferred way to use this function is through
<code>MyStructAsyncTryBuilder</code> and its <code>try_build_or_recover()</code> function.</p>
<h4 id="mystructtry_new_or_recover_async_sendefields---resultmystruct-e-heads"><a href="#mystructtry_new_or_recover_async_sendefields---resultmystruct-e-heads"><code>MyStruct::try_new_or_recover_async_send&lt;E&gt;(fields...) -&gt; Result&lt;MyStruct, (E, Heads)&gt;</code></a></h4>
<p>Same as <code>try_new_or_recover_async()</code> function, but with Send trait specified in the return type.</p>
<h4 id="mystructwith_fieldrself-user-fnoncefield-fieldtype---r---r"><a href="#mystructwith_fieldrself-user-fnoncefield-fieldtype---r---r"><code>MyStruct::with_FIELD&lt;R&gt;(&amp;self, user: FnOnce(field: &amp;FieldType) -&gt; R) -&gt; R</code></a></h4>
<p>This function is generated for every <strong>tail and immutably-borrowed field</strong> in your struct. It
allows safely accessing
a reference to that value. The function generates the reference and passes it to <code>user</code>. You
can do anything you want with the reference, it is constructed to not outlive the struct.</p>
<h4 id="mystructborrow_fieldself---fieldtype"><a href="#mystructborrow_fieldself---fieldtype"><code>MyStruct::borrow_FIELD(&amp;self) -&gt; &amp;FieldType</code></a></h4>
<p>This function is generated for every <strong>tail and immutably-borrowed field</strong> in your struct. It
is equivalent to calling <code>my_struct.with_FIELD(|field| field)</code>. It is only generated for types
which are known to be covariant, either through the macro being able to detect it or through the
programmer adding the <code>#[covariant]</code> annotation to the field.
There is no <code>borrow_FIELD_mut</code>, unfortunately, as Rust’s
borrow checker is currently not capable of ensuring that such a method would be used safely.</p>
<h4 id="mystructwith_field_mutrmut-self-user-fnoncefield-mut-fieldtype---r---r"><a href="#mystructwith_field_mutrmut-self-user-fnoncefield-mut-fieldtype---r---r"><code>MyStruct::with_FIELD_mut&lt;R&gt;(&amp;mut self, user: FnOnce(field: &amp;mut FieldType) -&gt; R) -&gt; R</code></a></h4>
<p>This function is generated for every <strong>tail field</strong> in your struct. It is the mutable version
of <code>with_FIELD</code>.</p>
<h4 id="mystructwithrself-user-fnoncefields-allfields---r---r"><a href="#mystructwithrself-user-fnoncefields-allfields---r---r"><code>MyStruct::with&lt;R&gt;(&amp;self, user: FnOnce(fields: AllFields) -&gt; R) -&gt; R</code></a></h4>
<p>Allows borrowing all <strong>tail and immutably-borrowed fields</strong> at once. Functions similarly to
<code>with_FIELD</code>.</p>
<h4 id="mystructwith_mutrself-user-fnoncefields-allfields---r---r"><a href="#mystructwith_mutrself-user-fnoncefields-allfields---r---r"><code>MyStruct::with_mut&lt;R&gt;(&amp;self, user: FnOnce(fields: AllFields) -&gt; R) -&gt; R</code></a></h4>
<p>Allows mutably borrowing all <strong>tail fields</strong> and immutably borrowing all <strong>immutably-borrowed</strong>
fields at once. Functions similarly to <code>with_FIELD_mut</code>, except that you can borrow multiple
fields as mutable at the same time and also have immutable access to any remaining fields.</p>
<h4 id="mystructinto_headsself---heads"><a href="#mystructinto_headsself---heads"><code>MyStruct::into_heads(self) -&gt; Heads</code></a></h4>
<p>Drops all self-referencing fields and returns a struct containing all <strong>head fields</strong>.</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ouroboros" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0 (2c8cc3432 2023-03-06)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>